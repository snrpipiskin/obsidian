---
noteId: 1743196639068
---

# Сборщик мусора (GC) в Go

**Garbage Collector (GC)** — автоматический механизм управления памятью, встроенный в [[obsidian/База для собесов копия/Темы к собесам/Go Runtime]]. Отслеживает объекты в [[obsidian/База для собесов копия/Темы к собесам/Память в Go#**Куча (Heap) - медленнее стека**|куче]] и освобождает память от неиспользуемых.

## 1. Базовая информация

- **Алгоритм**: Конкурентный трёхцветный (Mark-and-Sweep). В Go 1.25+ доступен Green Tea.
- **Область действия**: **Куча (Heap)**. Стек очищается автоматически.
- **Стоимость**: ~25% CPU (фоновая нагрузка), микропаузы STW (задержки).

---

## 2. Устройство и Алгоритмы (Concepts)

Основные механизмы, на которых строится работа GC.

### Корни (Roots)
Точки входа в граф объектов. Сканирование всегда начинается с них:
1. **Глобальные переменные** (секции BSS/Data).
2. **Стеки горутин** (локальные переменные и аргументы).
3. **Регистры процесора**.

### Трёхцветный алгоритм (Tricolor Mark)
Метод раскраски графа для отделения живых объектов от мусора:
- **Белый (White)**: Не посещен. Кандидат на удаление. В конце цикла всё белое — мусор.
- **Серый (Grey)**: Посещен (жив), но ссылки из него еще не проверены. Очередь задач.
- **Черный (Black)**: Посещен и полностью сканирован. Гарантированно жив.

### Stop-the-World (STW)
Глобальная остановка всех горутин (потоков M).
- **Зачем**: Синхронизация состояния памяти при смене фаз.
- **Механизм**: Сигнал `SIGURG` (Async Preemption) прерывает потоки даже в плотных циклах.
- **Частота**: Ровно 2 раза за цикл (в начале и при завершении разметки).

### Гибридный барьер записи (Hybrid Write Barrier)
Механизм защиты инварианта во время конкурентной работы.
- **Проблема**: Программа (мутатор) может переместить ссылку из "серого" объекта в "черный", пока GC сканирует другое.
- **Решение**: Барьер перехватывает запись указателя и красит его в "серый".
- **Результат**: GC не теряет живые объекты, даже если они перемещаются.

---

## 3. Фазы работы (GC Cycle)

Хронология одного цикла сборки мусора:

### 1. Sweep Termination (Подготовка) [STW]
Короткая остановка мира (< 10-100 мкс).
- Завершение всех операций предыдущего цикла.
- Включение **Write Barrier**.

### 2. Mark (Разметка) [Конкурентно]
Основная работа (~75% CPU программы).
- Сканирование **Корней** (стеки, глобалы).
- Запуск **Трёхцветного алгоритма**: перебор "серых" объектов, пока очередь не опустеет.
- Работает параллельно с программой пользователя.

### 3. Mark Termination (Завершение) [STW]
Вторая остановка мира (< 100 мкс).
- Досканирование остатков (обычно пусто).
- Расчет времени старта следующего цикла (**GC Pacing**).
- Отключение **Write Barrier**.

### 4. Sweep (Очистка) [Конкурентно]
Возврат памяти "белых" объектов аллокатору.
- Происходит **лениво (Lazy)**: при новых аллокациях `mallocgc` находит белые блоки и переиспользует их.
- Фоновый **сборщик (Scavenger)** возвращает свободную физическую память ОС (`madvise`).

---

## 4. Триггеры запуска

1. **GOGC (Heap Growth)**: Старт при росте живой кучи на N% (def: 100%).
2. **GOMEMLIMIT**: Агрессивный старт при лимите памяти (риск спирали смерти OOM).
3. **Manual**: `runtime.GC()`.
4. **Interval**: Каждые 2 минуты (если простой).

---

## 5. Green Tea GC (Go 1.25+)

**Суть**: Смена парадигмы с "рекурсивного обхода графа" на "линейное сканирование регионов". Решает проблему деградации производительности на огромных кучах (>100GB).

### Проблема: Прыжки по указателям (Pointer Chasing)
Классический GC работает как паук, прыгающий по ссылкам.
- При обходе `Object A -> Object B -> Object C` адреса памяти могут быть разбросаны.
- Это убивает кэш процессора (**промахи кэша**, Cache Misses) и TLB. CPU простаивает, ожидая данные из RAM.

### Решение: Сканирование по регионам (Region-Based Scanning)
Green Tea делит кучу на огромные регионы (**Regions**), использующие **большие страницы памяти (Huge Pages)** размером 2MB+.

#### 1. Линейное сканирование (Linear Scan)
Вместо прыжков по графу (`Объект А -> Объект Б -> Объект В`), GC просто читает память подряд (`Адрес 1, Адрес 2, Адрес 3...`).
- **Игнорирует связи**: Ему не важно, кто на кого ссылается. Он сканирует физические страницы памяти.
- **Аппаратный предзагрузчик (Hardware Prefetcher)**: Процессор видит предсказуемое последовательное чтение и заранее подгружает данные в кэш.

#### 2. Векторизация (SIMD / AVX-512)
Благодаря линейной структуре, GC использует векторные инструкции **AVX-512**.
- За один такт CPU проверяется не 1 указатель, а сразу пачка (8-16 штук).
- Это дает кратный прирост скорости проверки ("pointer or scalar?").

#### 3. Оптимизации для Cgo
Классический GC требует сложных барьеров при переходе Go <-> C.
- Green Tea упрощает взаимодействие, так как сканирование регионов менее чувствительно к "грязным" стекам Cgo. Накладные расходы на вызовы C функций снижаются.

| Характеристика | Классический GC | Green Tea GC |
| :--- | :--- | :--- |
| **Логика обхода** | По графу (кто на кого ссылается) | По памяти (адрес за адресом) |
| **Доступ к RAM** | Случайный (Random) | Последовательный (Linear) |
| **Эффективность кэша** | Низкая (разрушение кэша) | Высокая (дружественна к предзагрузке) |
| **Инструкции** | Скалярные (по одному) | Векторные (AVX-512, SIMD) |
| **Масштабируемость** | Падает с ростом графа | Линейна от объема памяти |

---

## 6. Тюнинг и Диагностика

### Основные настройки (Environment Variables)

#### 1. GOGC (Target Heap Size)
Определяет, как часто запускать GC относительно роста кучи.
- **Формула**: `Goal = Live + (Live * GOGC / 100)`
- **`GOGC=100`** (default): GC стартанет, когда новый мусор сравняется с живыми данными (рост на 100%).
- **`GOGC=200`**: Рост на 200% (реже GC, больше памяти). Используйте для снижения CPU нагрузки.
- **`GOGC=off`**: Полное отключение GC.

#### 2. GOMEMLIMIT (Memory Limit)
Мягкий лимит памяти, который Runtime старается не превышать.
- **Работает вместе с GOGC**: Если память растет, но лимит далеко — работает GOGC. Если лимит близко — GC запускается агрессивнее.
- **Зачем**: Для контейнеров (Kubernetes), чтобы избежать OOM Kill.
- **Особенность**: Это не жесткий лимит! При резких скачках аллокаций он может быть превышен.

### Диагностика (Debugging)

#### GODEBUG=gctrace=1
Выводит лог каждого цикла GC в stderr.
Формат: `gc # @time P% wall clock ...`
- `gc #`: Номер цикла.
- `@time`: Время от старта программы.
- `P%`: Процент времени CPU, потраченного на GC.
- `wall clock`: Реальное время выполнения фаз.

#### Runtime Metrics
Для мониторинга в Prometheus/Grafana:
- `/gc/cycles/total`: Счетчик циклов (частота запуска).
- `/gc/pauses`: Гистограмма пауз STW (latency).
- `/gr/heap/alloc`: Текущий размер кучи.

---

## Дополнительные источники
- [A Guide to the Go Garbage Collector](https://go.dev/doc/gc-guide)
- [[obsidian/База для собесов копия/Темы к собесам/Память в Go]] — устройство аллокатора.
