---
noteId: 1743196638973
related:
  - "[[obsidian/База для собесов копия/Темы к собесам/Go Runtime]]"
  - "[[obsidian/База для собесов копия/Темы к собесам/Планировщик]]"
---

# Работа с синхронизацией в Go (пакет `sync` и `sync/atomic`)

Go поощряет подход "Do not communicate by sharing memory; instead, share memory by communicating" (используйте каналы). Однако для высокопроизводительных участков кода и простых счетчиков классические примитивы синхронизации часто эффективнее и проще.

---

## 1. Mutex (Мьютексы)

### `sync.Mutex` — Полная блокировка
Самый базовый примитив. Гарантирует, что только одна горутина может исполнять критическую секцию кода в данный момент времени.

**Методы:**
- `Lock()`: захватить мьютекс (если занят — ждать).
- `Unlock()`: освободить мьютекс.

**Пример:**
```go
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock() // Всегда используйте defer для разблокировки!
    c.value++
}
```

### `sync.RWMutex` — Блокировка чтения/записи
Оптимизирован для сценариев, где **чтений много, а записей мало**.
- Позволяет множеству горутин читать одновременно (`RLock`).
- Запись (`Lock`) блокирует и читателей, и писателей (эксклюзивный доступ).

**Методы:**
- `Lock()` / `Unlock()`: для записи (эксклюзивно).
- `RLock()` / `RUnlock()`: для чтения (параллельно с другими RLock).

**Пример:**
```go
type Config struct {
    mu   sync.RWMutex
    data map[string]string
}

func (c *Config) Get(key string) string {
    c.mu.RLock()         // Блокируем для чтения
    defer c.mu.RUnlock()
    return c.data[key]
}

func (c *Config) Set(key, value string) {
    c.mu.Lock()          // Блокируем для записи (никто больше не может читать/писать)
    defer c.mu.Unlock()
    c.data[key] = value
}
```

---

## 2. WaitGroup (Ожидание группы)

### `sync.WaitGroup`
Используется, чтобы дождаться завершения работы набора горутин.

**Внимание:** `WaitGroup` нельзя копировать после первого использования (передавайте по указателю!).

**Методы:**
- `Add(delta int)`: добавить N задач (или уменьшить, если delta < 0).
- `Done()`: то же, что `Add(-1)`.
- `Wait()`: блокируется, пока счетчик не станет равен 0.

**Пример:**
```go
var wg sync.WaitGroup

for i := 0; i < 3; i++ {
    wg.Add(1) // Увеличиваем ДО запуска горутины
    go func(id int) {
        defer wg.Done()
        fmt.Printf("Worker %d done\n", id)
    }(i)
}

wg.Wait() // Ждем всех
fmt.Println("All done")
```

---

## 3. Once (Единократное выполнение)

### `sync.Once`
Гарантирует, что функция будет вызвана **ровно один раз**, даже если `Do()` вызывается из тысяч горутин одновременно. Идеально для ленивой инициализации (синглтонов).

**Пример:**
```go
var once sync.Once
var instance *DbConnection

func GetInstance() *DbConnection {
    once.Do(func() {
        fmt.Println("Initializing DB...")
        instance = &DbConnection{}
    })
    return instance
}
```

---

## 4. Atomic (Атомарные операции)

### Пакет `sync/atomic`
Самые быстрые и низкоуровневые примитивы. Выполняются на уровне процессора. Используются для простых счетчиков и флагов, когда мьютексы слишком "тяжелые".

**Основные операции:**
- `AddInt64(&val, delta)`: атомарное сложение.
- `LoadInt64(&val)`: атомарное чтение.
- `StoreInt64(&val, new_val)`: атомарная запись.
- `CompareAndSwapInt64(&val, old, new)`: CAS (заменить, если значение равно old).

**Пример:**
```go
var ops atomic.Int64 // С Go 1.19 появились удобные типы-обертки

func worker() {
    ops.Add(1) // Потокобезопасно без мьютексов
}
```

---

## 5. Map (Конкурентная карта)

### `sync.Map`
Специализированная карта, безопасная для конкурентного доступа. **Не требуется** `make` для инициализации.

**Когда использовать (вместо `Mutex + map`):**
1. Когда запись происходит только один раз, а чтение — много раз (Cache).
2. Когда разные горутины работают со строго непересекающимися наборами ключей.

**В обычных случаях `Mutex + map` быстрее и типизированнее.**

**Методы:**
- `Store(key, value)`
- `Load(key) (value, ok)`
- `LoadOrStore(key, value) (actual, loaded)`
- `Delete(key)`
- `Range(func(key, value any) bool)`

---

## 6. Pool (Пул объектов)

### `sync.Pool`
Используется для **снижения нагрузки на Garbage Collector** путем переиспользования объектов.
**Важно:** Объекты в пуле могут быть удалены GC в любой момент (обычно между циклами GC). Не используйте для хранения важных данных (сокетов, соединений с БД).

**Пример:**
```go
var bufPool = sync.Pool{
    New: func() any {
        return new(bytes.Buffer) // Создаем новый, если пул пуст
    },
}

func Log(data string) {
    b := bufPool.Get().(*bytes.Buffer) // Взять из пула
    b.Reset()
    b.WriteString(data)
    process(b)
    bufPool.Put(b) // Вернуть в пул
}
```

---

## 7. Cond (Условная переменная)

### `sync.Cond`
Самый редкий и сложный примитив. Позволяет горутинам ждать ("спать") до определенного события (сигнала). Всегда используется в связке с `Locker` (обычно Mutex).

**Методы:**
- `Wait()`: разблокирует мьютекс и засыпает. Когда проснется — снова блокирует мьютекс.
- `Signal()`: разбудить одну случайную горутину.
- `Broadcast()`: разбудить **все** горутины.

**Пример:**
```go
c := sync.NewCond(&sync.Mutex{})
ready := false

// Читатель
go func() {
    c.L.Lock()
    for !ready { // Всегда проверяйте условие в цикле!
        c.Wait()
    }
    fmt.Println("Work done")
    c.L.Unlock()
}()

// Писатель
time.Sleep(1 * time.Second)
c.L.Lock()
ready = true
c.Broadcast() // Всем проснуться!
c.L.Unlock()
```

---

## Best Practices

1.  **Не копируйте примитивы синхронизации.** Почти все структуры (Mutex, WaitGroup) содержат внутреннее состояние и не должны копироваться. Передавайте их по указателю.
    *   *Совет:* Используйте `go vet`, он найдет такие ошибки.
2.  **Избегайте Deadlock.** Всегда захватывайте мьютексы в одном и том же порядке.
3.  **Unlock в defer.** Это гарантирует, что мьютекс разблокируется даже при панике.
4.  **Data Race Detector.** Запускайте тесты с флагом `-race`, чтобы найти гонки данных.