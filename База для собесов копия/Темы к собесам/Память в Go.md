---
noteId: 1743196637255
---

# Память в Go (Stack & Heap)

[[obsidian/База для собесов копия/Темы к собесам/Go Runtime]] использует сложную модель управления памятью, основанную на **TCMalloc** (Thread-Caching Malloc). Это позволяет минимизировать блокировки и фрагментацию.

## 1. Стек (Stack) vs Куча (Heap)

| Характеристика     | Стек (Stack)                        | Куча (Heap)                        |
| :----------------- | :---------------------------------- | :--------------------------------- |
| **Скорость**       | Очень быстро (сдвиг регистра SP)    | Медленнее (поиск блока + GC)       |
| **Управление**     | Автоматическое (при вызове функций) | GC (Garbage Collector)             |
| **Конкурентность** | Локален для горутины (без локов)    | Общая память (нужна синхронизация) |
| **Размер**         | Динамический (2KB -> 1GB)           | Ограничен RAM                      |
| **Фрагментация**   | Нет (LIFO)                          | Возможна                           |
| **Локальность**    | Идеальная (CPU Cache friendly)      | Плохая (Pointer Chasing)           |

---

## 2. Стек (Stack)

Стек — это область памяти LIFO (Last In, First Out), предназначенная для выполнения функций.

### Особенности в Go
1. **Goroutine-Local**: У каждой горутины свой стек. Доступ к нему из другой горутины невозможен (поэтому не нужны мьютексы).
2. **Динамический размер (Dynamic Sizing)**:
    - **Старт**: При создании горутины выделяется всего **2KB** (в Linux).
    - **Рост**: Если функции нужно больше места, происходит **Stack Growth**.
    - **Лимит**: Максимум 1GB (для 64-bit) или 250MB (32-bit). Если превысит — `panic: stack overflow`.

### Механика роста (Stack Growth)
Компилятор вставляет проверку переполнения стека (`morestack`) в пролог каждой функции.
Если места мало:
1. Выделяется новый блок памяти **x2** от старого.
2. Все данные копируются в новый стек (`runtime.copystack`).
3. Указатели на стековые переменные обновляются (поэтому нельзя безопасно сохранять указатели на стек долгоживущим C-кодом).

---

## 3. Куча (Heap) и Аллокатор

Куча — это общая память процесса для динамических объектов (слайсы, мапы, объекты, пережившие функцию).
Go использует аллокатор на базе **TCMalloc** для снижения конкуренции (Lock Contention).

### Архитектура аллокатора

Память делится на три уровня:

#### 1. mcache (Thread Cache)
- Локальный кэш для каждого **P** (Processor).
- **Без блокировок**: Горутине не нужно брать lock, чтобы выделить память.
- Хранит готовые списки свободных блоков разных размеров (Size Classes).
- *Если есть место в mcache — аллокация мгновенна.*

#### 2. mcentral (Central Cache)
- Общий список свободных блоков ("спанов") всех размеров.
- **С блокировками**: Если `mcache` пуст, P обращается сюда под локом, забирает пачку блоков и кэширует у себя.

#### 3. mheap (Global Heap)
- Запрашивает память у операционной системы (через `mmap`).
- Управляет большими регионами памяти (**Arenas**, по 64MB).
- Хранит метаданные о страницах.

### Классы объектов
Аллокатор ведет себя по-разному в зависимости от размера объекта:
1. **Tiny (< 16B)**: Группируются в один блок 16B (экономия места). Не содержат указателей.
2. **Small (16B ... 32KB)**: Выделяются из `mcache` (предварительно нарезанные блоки).
3. **Large (> 32KB)**: Выделяются напрямую из `mheap` (обходят кэши, сразу страницы).

---

## 4. Escape Analysis (Анализ побега)

Этап компиляции, на котором решается: где выделить память — на стеке или в куче.
**Правило**: Если время жизни переменной выходит за пределы функции или её размер слишком велик — она "убегает" в кучу.

Команда для проверки:
```bash
go build -gcflags="-m" main.go
```

### Основные причины побега (Escape Scenarios)

1. **Возврат указателя (Pointer Return)**:
    ```go
    func New() *User {
        u := User{} // u убегает в кучу, так как нужна после возврата
        return &u
    }
    ```

2. **Интерфейсы (Dynamic Dispatch)**:
    Методы интерфейсов часто требуют кучи, так как размер реализации неизвестен на этапе компиляции.
    ```go
    fmt.Println(a) // a (interface{}) убегает
    ```

3. **Слишком большие переменные (Too Large)**:
    Если стек (2KB) не вмещает объект (например, `make([]int, 1000000)`), он сразу идет в кучу.

4. **Динамический размер (Unknown Size)**:
    `make([]int, n)` — если `n` не константа, это куча.

5. **Замыкания (Closures)**:
    Переменные, захваченные замыканием, могут убегать, если живут дольше функции.

---

## 5. Выравнивание памяти (Memory Alignment)

CPU читает память "словами" (machine words, 64-bit = 8 bytes). Для эффективности данные выравниваются по границам слова. Это создает **Padding** (пустоты).

### Пример оптимизации
```go
// Bad: 24 bytes (из-за padding)
type Bad struct {
    Flag    bool  // 1 byte + 7 padding
    Counter int64 // 8 bytes
    Active  bool  // 1 byte + 7 padding
}

// Good: 16 bytes (поля упакованы)
type Good struct {
    Counter int64 // 8 bytes
    Flag    bool  // 1 byte
    Active  bool  // 1 byte
    // + 6 bytes padding в конце
}
```
**Совет**: Располагайте поля от большего размера к меньшему (int64 -> int32 -> bool).

---

## Дополнительные источники
- [Go Memory Allocator Visual Guide](https://blog.learngopro.com/go-memory-allocator-visual-guide/)
- [[obsidian/База для собесов копия/Темы к собесам/Сборщик мусора (GC)]]
- `src/runtime/malloc.go`
