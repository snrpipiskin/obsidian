---
noteId: 1743196645451
---

## **Аллокатор памяти в Go**

Аллокатор памяти в Go отвечает за выделение и управление [[obsidian/База для собесов копия/Темы к собесам/Память в Go|памятью]] для объектов во время выполнения программы.

### Основные компоненты аллокатора:

| Компонент                                 | Описание                                                                 |
| ----------------------------------------- | ------------------------------------------------------------------------ |
| **Малый объект (Small object)**           | Выделяется в пуле, размер до 32 КБ                                       |
| **Большой объект (Large object)**         | Выделяется напрямую в куче                                               |
| **Массив свободных списков (Free lists)** | Управляет списками освобожденных блоков памяти для переиспользования     |
| **Span**                                  | Минимальная единица управления памятью в Go, содержит несколько объектов |
| **Page Heap**                             | Управляет большими блоками памяти                                        |

### Механизм выделения памяти

1. Малые объекты выделяются из **свободных списков**.
2. Большие объекты выделяются из **кучи**.
3. Аллокатор использует **arena-based memory allocation**.

Go использует стратегию **мягкого управления памятью** для уменьшения частых вызовов `syscall` для выделения страниц памяти.

## **[[obsidian/База для собесов копия/Темы к собесам/Сборщик мусора (GC)|Сборщик мусора]] (Garbage Collector, GC)**

Go использует **конкурентный трицветный алгоритм** сборки мусора, который работает в фоновом режиме, минимизируя паузы выполнения программы.

### Этапы работы GC

|Этап|Описание|
|---|---|
|**Пометка (Marking)**|Обход всех достижимых объектов и их пометка как "живых"|
|**Очистка (Sweeping)**|Освобождение памяти для объектов, которые не были помечены как "живые"|
|**Сжатие (Compaction)**|Перемещение оставшихся объектов для уменьшения фрагментации|

### Особенности GC в Go:

- **Конкурентность** – работает параллельно с выполнением программы.
- **Трехцветная разметка** – объекты делятся на **белые (подлежат удалению), серые (проверяются), черные (живые)**.
- **Снижение пауз (low-pause GC)** – основной фокус на снижении времени остановки программы.
- **Механизм write barrier** – предотвращает модификацию объектов во время работы GC.

## **[[obsidian/База для собесов копия/Темы к собесам/Планировщик|Планировщик]] (Scheduler)**

Go использует **M:N планировщик**, где `M` – это количество системных потоков, а `N` – количество горутин.

### Основные компоненты планировщика:

|Компонент|Описание|
|---|---|
|**G (goroutine)**|Представляет горутину в Go|
|**M (machine)**|Соответствует системному потоку ОС|
|**P (processor)**|Логический процессор, управляет очередью горутин|

### Как планировщик выполняет код?

1. Горутине (`G`) назначается процессор (`P`).
2. Процессор (`P`) выполняет горутину (`G`) на системном потоке (`M`).
3. Если `G` блокируется, `P` может назначить другой `G` на `M`.
4. Если `M` блокируется, `P` передается другому `M`.
5. Работает механизм **work stealing** для балансировки нагрузки между `P`.

### Механизмы оптимизации в планировщике:

- **Work Stealing** – горутины могут забирать задачи у других процессоров `P`, если их очередь пуста.
- **Глобальная очередь** – если локальные очереди горутин пусты, `P` берет задачи из общей очереди.
- **Горизонтальное масштабирование** – автоматически увеличивает количество `M` при необходимости.

## **[[30 Interests/31 Programming/Go/База для собесов/Темы к собесам/Каналы|Каналы]] и их реализация**

Go использует **каналы** (`chan`) для синхронизации и передачи данных между горутинами.

### Внутреннее устройство каналов

|Компонент|Описание|
|---|---|
|**Буферизированный канал**|Хранит очередь сообщений, не блокирует отправителя, пока есть место|
|**Небуферизированный канал**|Передача сообщения происходит только при наличии получателя|
|**Список ожидания**|Очередь горутин, ожидающих отправку/получение|
|**Mutex и семафоры**|Управляют доступом к структурам каналов|

### Механизм работы каналов:

1. Если канал пуст – горутина отправителя блокируется.
2. Если канал полный – горутина отправителя блокируется.
3. Когда в канал добавляются данные – разблокируется получатель.

## **Основные функции пакета `runtime`

Go предоставляет **пакет `runtime`**, который позволяет управлять планировщиком и анализировать производительность.

### Важные функции из `runtime`

|Функция|Описание|
|---|---|
|`runtime.GOMAXPROCS(n int)`|Устанавливает максимальное количество процессоров `P`|
|`runtime.NumGoroutine()`|Возвращает количество запущенных горутин|
|`runtime.Gosched()`|Передает управление другой горутине|
|`runtime.Goexit()`|Завершает текущую горутину|
|`runtime.ReadMemStats()`|Читает статистику использования памяти|


