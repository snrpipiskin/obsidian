---
noteId: 1743196628428
---


## **==База по интерфейсам==**

### **Неявная имплементация**

Интерфейсы в Go реализуются **неявно**. Тип **не объявляет**, что он реализует интерфейс — если он содержит **все методы** интерфейса, он автоматически удовлетворяет ему.

``` Go
type User struct {
  name     string
  age      int
  lastName string
}

type Document struct {
  name         string
  documentType string
  date         time.Time
}

// Реализация метода Print для Document
func (d Document) Print() {
  fmt.Printf("Document name: %s, type: %s, date: %s \n", d.name, d.documentType, d.date)
}

// Реализация метода Print для User
func (u User) Print() {
  fmt.Printf("Hi I am %s %s and I am %d years old \n", u.name, u.lastName, u.age)
}
```

### **Интерфейс в [[obsidian/База для собесов Копия/Темы к собесам/Память в Go|памяти]]**

``` Go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
```

Интерфейс содержит **тип** и **значение**, а структуры — только **данные**, но не поведение.

---

## **Использование интерфейсов**

### **Причины использования интерфесов**

1. **Уменьшают дублирование кода** и позволяют работать с разными структурами одинаково.
    
2. **Позволяют заменять реальные объекты в тестах моками**.
    
3. **Облегчают архитектурное разделение**, отвязывая код от конкретных реализаций.
    

### **Использование интерфейсов в работе**

- Интерфейсы объявляются рядом со структурами.
    
- Используются в локальных местах, где нужна абстракция поведения.

---

## **Динамическое приведение типов**

### **Type Switch**

Позволяет определить **конкретный тип** значения, если оно хранится в интерфейсе.

```
var data interface{} = 42

switch v := data.(type) {
case int:
    fmt.Println("Это int со значением:", v)
case string:
    fmt.Println("Это строка:", v)
default:
    fmt.Println("Неизвестный тип")
}
```

### **Утиная типизация**

В Go неважно, **к какому конкретному типу** принадлежит объект — если он имеет нужные методы, он может быть использован вместо интерфейса.

---

## **Функции в строготипизированном языке**

### **Дженерики в Go**

Позволяют писать **типобезопасные** универсальные функции:

```
type List[T any] struct {
    items []T
}

func (l *List[T]) Add(item T) {
    l.items = append(l.items, item)
}
```

---

## **Пустой интерфейс и его использование**

До появления дженериков **пустой интерфейс** `interface{}` использовался для хранения значений **любого типа**.

```
func PrintAny(value interface{}) {
    fmt.Println(value)
}
```

> Сейчас вместо `interface{}` лучше использовать `any`, если не нужны методы.

---