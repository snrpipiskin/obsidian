---
noteId: 1743196628683
---

# Каналы в Go

**Каналы (`chan`)**- механизм, которые используются для связи между **[[obsidian/База для собесов Копия/Темы к собесам/Горутина|горутинами]]** и синхронизации их выполнения. Они позволяют безопасно передавать значения между потоками выполнения без использования [[obsidian/База для собесов Копия/Темы к собесам/Работа с синхронизацией в Go (sync)|мьютексов]].

![[browser_57zdXDWWXA.png]]

## 1. Основные свойства
- **Ссылочный тип**: Переменная канала — это указатель на структуру в куче.
- **Потокобезопасность**: Доступ к внутренним структурам канала защищен встроенным мьютексом.
- **FIFO**: Данные всегда извлекаются в том же порядке, в котором были записаны.

---

## 2. Внутреннее устройство (hchan)

Под капотом канал представлен структурой `hchan`. Когда вы вызываете `make(chan int, 10)`, Go выделяет память под эту структуру и буфер.

```go
type hchan struct {
    qcount   uint           // Количество элементов в буфере
    dataqsiz uint           // Размер буфера (capacity)
    buf      unsafe.Pointer // Указатель на массив элементов (кольцевой буфер)
    elemsize uint16         // Размер одного элемента
    closed   uint32         // Флаг закрытия канала
    elemtype *_type        // Тип элементов в канале
    sendx    uint           // Индекс следующей записи в буфере
    recvx    uint           // Индекс следующего чтения из буфера
    recvq    waitq          // Список горутин, ожидающих чтения (очередь sudog)
    sendq    waitq          // Список горутин, ожидающих записи (очередь sudog)
    lock     mutex          // Мьютекс для защиты всех полей hchan
}
```

### Sudog и Очереди ожидания
Если горутина пытается записать в полный канал или прочитать из пустого, она блокируется. Рантайм создает структуру **sudog**, которая связывает горутину с каналом, и помещает её в `recvq` или `sendq`. sudog — это "представление" горутины в очередях ожидания.

---

## 3. Deadlock (Взаимная блокировка)

**Deadlock** — ситуация, когда горутина блокируется в ожидании данных из канала (или записи в него), но в системе не осталось других активных горутин, которые могли бы разблокировать её.

Планировщик Go отслеживает такие ситуации в рантайме. Если все горутины заблокированы и нет активных обработчиков, программа завершается с фатальной ошибкой: `fatal error: all goroutines are asleep - deadlock!`.

---

## 4. Виды каналов

### Небуферизированные (Синхронные)
Передача данных происходит только тогда, когда и отправитель, и получатель одновременно готовы. Если один не готов, другой блокируется.
```go
ch := make(chan int) // dataqsiz = 0
```

### Буферизированные (Асинхронные)
Имеют внутреннее хранилище (кольцевой буфер). Отправитель не блокируется, пока в буфере есть свободное место. Получатель не блокируется, пока в буфере есть данные.
```go
ch := make(chan int, 10) // dataqsiz = 10
```

### Однонаправленные
Используются в сигнатурах функций для ограничения прав доступа к каналу.
```go
func sendOnly(ch chan<- int)    // Только для записи
func receiveOnly(ch <-chan int) // Только для чтения
```

---

## 5. Поведение каналов (Таблица состояний)

| Состояние канала | Запись (`ch <- v`) | Чтение (`<- ch`)                             | Закрытие (`close(ch)`) |
| :--------------- | :----------------- | :------------------------------------------- | :--------------------- |
| **Nil**          | **Deadlock**       | **Deadlock**                                 | **Panic**              |
| **Открыт**       | Ожидание/Запись    | Ожидание/Чтение                              | Успешно                |
| **Закрыт**       | **Panic**          | Вернет `zero value` (false во 2-м аргументе) | **Panic**              |
![[browser_e7sPmPSMts.png]]
![[browser_YG7KmLYLq4.png]]
![[browser_6M926PZMmo.png]]
![[browser_YeGIOZDmEz 2.png]]

---

## 6. Селектор Select

`select` позволяет горутине ожидать выполнения нескольких операций с каналами одновременно.
- Если готовы несколько каналов — выбирается **случайный**.
- Если ни один не готов и есть `default` — выполняется `default`.
- Если `default` нет — горутина блокируется до готовности любого из каналов.

```go
select {
case v := <-ch1:
    fmt.Println("Из канала 1:", v)
case ch2 <- 10:
    fmt.Println("Записали в канал 2")
default:
    fmt.Println("Никто не готов")
}
```

---

## 7. Паттерны и использование

### Worker Pool
Распределение задач между несколькими горутинами-обработчиками через общий канал задач.

### Завершение (Done Channel)
Использование пустого канала для сигнализации об окончании работы. Когда канал закрывается, все читающие горутины получают сигнал мгновенно.

### Пример: Generator и Filter
```go
func generate(n int, ch chan<- int) {
    defer close(ch)
    for i := 1; i <= n; i++ {
        ch <- i
    }
}

func filterEven(in <-chan int, out chan<- int) {
    defer close(out)
    for v := range in {
        if v%2 == 0 {
            out <- v
        }
    }
}
```

---

## Дополнительные источники
- [Анатомия каналов в Go / habr](https://habr.com/ru/articles/490336/)
- [Визуализация работы каналов (Go visualizer)](https://go101.org/article/channel.html)
- [[obsidian/База для собесов Копия/Темы к собесам/Горутина|Заметка про горутины]] — как каналы управляют состоянием горутин.
