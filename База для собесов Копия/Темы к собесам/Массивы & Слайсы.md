---
noteId: 1743196633564
---

# Массивы и Слайсы в Go

## 1. Массивы (Arrays)

**Массив** — это последовательность элементов одного типа **фиксированного размера**. 

- **Копирование**: При передаче в функцию массив копируется целиком (передача по значению).
- **Память**: Маленькие массивы обычно хранятся на стеке, большие — в куче.

```go
arr := [3]int{1, 2, 3}
func change(a [3]int) { a[0] = 9 } // Изменится только копия внутри функции
```

![[Untitled 21.png]]

---

## 2. Слайсы (Slices)

**Слайс** — это динамическая обертка над массивом. Он не хранит данные сам, а лишь описывает, какую часть базового массива мы используем.

### Внутреннее устройство
В рантайме слайс — это легкая структура заголовка (**24 байта** на 64-бит), которая управляет данными.

```go
type slice struct {
    array unsafe.Pointer // Указатель на подлежащий массив
    len   int            // Длина (сколько элементов доступно для чтения)
    cap   int            // Емкость (сколько всего элементов от начала "окна" до конца массива)
}
```

### Аллокация памяти
Данные, на которые указывает `array`, аллоцируются отдельно:
- При создании через `make([]int, 100)`: Заголовок создается на стеке, а массив на 100 элементов — в **куче** (если он "убегает" из функции) или тоже на стеке (если компилятор видит, что он не покидает функцию).
- `append` может триггерить новую аллокацию массива в куче, если старой емкости не хватает.

![[Untitled 20.png]]

### Передача в функции (Pass by Value)

В Go **все** передается по значению (копируется). Но поведение зависит от типа:

1.  **Массивы (`[N]T`)**: Копируются **целиком**.
    *   Если передать массив на 1 млн элементов, он весь скопируется в памяти. Это медленно.
2.  **Слайсы (`[]T`)**: Копируется только **заголовок** (24 байта).
    *   В заголовке лежит **указатель** (`array pointer`) на данные.
    *   Поэтому, когда функция получает слайс, она получает *копию указателя*, который смотрит на **тот же самый** массив в памяти.
    *   **Эффект**: Изменения элементов (через индекс) **видны** снаружи (как по ссылке).
    *   **Нюанс**: `append` может заменить указатель в *локальной копии* заголовка (при реалокации), и тогда связь с внешним миром для новых элементов потеряется.

### Сравнение: Массивы vs Слайсы

| Характеристика    | Массив (Array)                                | Слайс (Slice)                                    |
| :---------------- | :-------------------------------------------- | :----------------------------------------------- |
| **Размер**        | Фиксированный, часть типа `[5]int`            | Динамический, может меняться                     |
| **Передача**      | **Value Semantic**: Копируется все содержимое | **Pointer Semantic**: Копируется заголовок (ptr) |
| **Сравнение**     | Можно сравнивать == (если элементы сравнимы)  | Нельзя сравнивать == (только с `nil`)            |
| **Zero Value**    | Массив из нулей/пустых строк                  | `nil`                                            |
| **Использование** | Редко, когда нужен фикс. буфер                | Повсеместно как основной инструмент              |

---

## 3. Рост и Append

### Алгоритм роста (Go 1.18+)
`append` проверяет условие: `len + 1 > cap`. Если места **НЕ** хватает, запускается алгоритм роста и **выделение новой памяти**.

Раньше слайс удваивался до 1024 элементов. Теперь формула более плавная:
1.  **`cap < 256`**: Емкость удваивается ($2x$).
2.  **`cap >= 256`**: Используется формула для плавного перехода от $2x$ к $1.25x$:
    `newcap = oldcap + (oldcap + 3*256) / 4`

![[Untitled 1 13.png]]

---

## 4. Особенности работы

### Nil vs Empty Slices

| Состояние | Объявление | `len` | `cap` | `slice == nil` | Ссылка на массив |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Nil slice** | `var s []int` | 0 | 0 | **true** | `nil` |
| **Empty slice** | `s := []int{}` | 0 | 0 | **false** | Указывает на `zerobase` |
| **Make slice** | `s := make([]int, 0)`| 0 | 0 | **false** | Указывает на `zerobase` |

> [!important]
> Для проверки на "пустоту" всегда используйте `len(s) == 0`, так как это работает и для `nil`, и для пустых слайсов.

### Слайсирование с 3 индексами
Позволяет ограничить емкость результирующего слайса, чтобы `append` в него не испортил данные в родительском слайсе.
`s[low : high : max]`
- `len = high - low`
- `cap = max - low`

```go
source := []int{0, 1, 2, 3, 4}
sub := source[1:3:3] // len=2, cap=2. Любой append вызовет аллокацию нового массива.
```

### Копирование (`copy`)
`copy(dst, src)` копирует минимальное из `len(dst)` и `len(src)` элементов. Это самый быстрый способ скопировать данные.

---

## 5. Проблемы и Оптимизация

### Утечки памяти (Memory Leak)
Если вы берете маленький срез от огромного слайса и храните его долгоживущую ссылку, GC не сможет очистить огромный подлежащий массив.

**Решение:** Всегда копируйте нужные данные в новый маленький слайс.
```go
func getSmall() []int {
    big := make([]int, 1000000)
    small := make([]int, 5)
    copy(small, big[:5]) 
    return small // big массив теперь может быть удален GC
}
```

### Потокобезопасность
Ни **массивы**, ни **слайсы** не являются потокобезопасными.
- **Слайсы**: Риск гонки данных (data race), плюс риск разрушения заголовка слайса при одновременном `append`.
- **Массивы**: Если несколько горутин имеют доступ к **одной и той же** памяти массива (через указатель или замыкание), одновременная запись приведет к гонке данных.

**Способы защиты:** [[obsidian/База для собесов Копия/Темы к собесам/Работа с синхронизацией в Go (sync)|sync.Mutex]], [[obsidian/База для собесов Копия/Темы к собесам/Работа с синхронизацией в Go (sync)|sync.RWMutex]], или каналы для передачи владения.

---

## Дополнительные источники
- [Go Blog: Slice Tricks](https://github.com/golang/go/wiki/SliceTricks)
- [Go Blog: Arrays, slices (and strings): The mechanics of 'append'](https://go.dev/blog/slices-intro)
- [[obsidian/База для собесов Копия/Темы к собесам/Контекст|Заметка про контекст]] — как передавать данные.
- [[obsidian/База для собесов Копия/Темы к собесам/Сборщик мусора (GC)]] — подробнее про очистку памяти.
- [[obsidian/База для собесов Копия/Темы к собесам/Память в Go]] - подробнее про работу памяти.
