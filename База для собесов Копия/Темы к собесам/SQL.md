---
noteId: 1743196649985
---

[[00 Meta/01 Attachments/SQL/Задачи|Задачи]]

  

АНДРЕЙ САЛЬНИКОВ

Без Индексов - Секвеншел скан

  

==**Оптимизация запросов**==

==**EXPLANE -**== Показывает план выполнения запроса, не выполняя запрос  
- Порядок сканирования таблиц  
- Используемые методы соединения  
- Предполагаемая стоимость выполнения каждой операции  

==**ANALYZE -**== Собирает статистику о таблицах в БД  
Статистика используется планировщиком запросов для создания более эффективных планов выполнения  

==**EXPLANE ANALYZE -**== Не только показывает планвыполнения запросов, но и выполняет запрос, предоставляя реальные данные о времени выполнения и кол-ве обработанных строк

**Показывает на сколько попадаем в индексы**  
**Сколько времени занимает**  

  

==**ОПТИМИСТИЧНЫЕ БЛОКИРОВКИ -**== **Играть с версиями**

==**ПЕССИМИСТИЧНЫЕ БЛОКИРОВКИ -**== **Блокировка Базы**

  

`Structure Query Language` - Язык структурирования запросов

`СУБД` - Система управления Базами Данных  
Реляционные -  
`Relation` - Связанные

  

`Primary Key` (Первичный Ключ) – это поле или комбинация полей, которые однозначно идентифицируют определенную строку в таблице. Первичный ключ важен, потому что он гарантирует отсутствие дубликатов строк в таблице, а также позволяет эффективно выполнять запросы и индексировать таблицу.  
  

`Foreign Key` (Внешний Ключ) – это столбец или набор столбцов, которые ссылаются на первичный ключ другой таблицы. Он используется для установления связи между двумя таблицами.

Добавление внешнего ключа в таблицу создает связь между данными в этой таблице и данными в другой таблице. Эта связь гарантирует, что данные в двух таблицах всегда будут соответствовать друг другу.

Мы можем удостовериться что в Таблицу не попадает запись которая ссылается на несуществующий ID

```SQL
SELECT 
Используется для выбора данных 
из таблицы или представления. 
Часто используется для получения информации 
для отображения на веб-страницах 
или в приложениях.

SELECT column1, column2 FROM table_name WHERE condition;
///
INSERT 
Используется для добавления 
новых строк данных в таблицу.

INSERT INTO table_name (column1, column2) VALUES (value1, value2);
///
UPDATE: 
Используется для обновления 
существующих строк данных в таблице.

UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition;
///
DELETE: 
Используется для удаления 
строк данных из таблицы.

DELETE FROM table_name WHERE condition;
///
JOIN: 
Используется для объединения 
строк из разных таблиц на основе заданного условия.

SELECT column1, column2 FROM table1 INNER JOIN table2 ON table1.column = table2.column;
///
GROUP BY: 
Используется для группировки
строк по значению определенного столбца.

SELECT column1, COUNT(*) FROM table_name GROUP BY column1;
///
ORDER BY: 
Используется для сортировки 
строк в результате запроса по заданному столбцу.

SELECT column1, column2 FROM table_name ORDER BY column1 ASC;
///
CREATE TABLE: 
Используется для создания 
новой таблицы в базе данных.

CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    ...
);
///
ALTER TABLE: 
Используется для изменения 
структуры существующей таблицы, 
например, добавления новых столбцов 
или изменения типа данных.

ALTER TABLE table_name ADD column_name datatype;
///
DROP TABLE: 
Используется для удаления 
таблицы из базы данных.

DROP TABLE table_name;
```

```SQL
CEILING(x)	
возвращает наименьшее целое число, 
большее или равное x
(округляет до целого числа в большую сторону)	
CEILING(4.2)=5
CEILING(-5.8)=-5

ROUND(x, k)	округляет значение 
x до k знаков после запятой,
если k не указано – x округляется до целого	
ROUND(4.361)=4
ROUND(5.86592,1)=5.9

FLOOR(x)	возвращает наибольшее целое число, 
меньшее или равное x
(округляет до  целого числа в меньшую сторону)	
FLOOR(4.2)=4
FLOOR(-5.8)=-6

POWER(x, y)	возведение x в степень y	
POWER(3,4)=81.0

SQRT(x)	квадратный корень из x	
SQRT(4)=2.0
SQRT(2)=1.41...

DEGREES(x)	конвертирует значение 
x из радиан в градусы	
DEGREES(3) = 171.8...

RADIANS(x)	конвертирует значение 
x из градусов в радианы	
RADIANS(180)=3.14...

ABS(x)	модуль числа x	ABS(-1) = 1
ABS(1) = 1

PI()	pi = 3.1415926...	 
```

  
  
==**ТРИГГЕР -**== Можно вешать на какие-то события в Базе  
И исполнять какой-то код по наступлению события  
Мониторить события в Базе  

  

==**ИНДЕКСЫ —**== это специальные поисковые таблицы (lookup tables), которые используются движком БД в целях более быстрого извлечения данных.  
Проще говоря, индекс — это указатель или ссылка на данные в таблице.  

```SQL
CREATE INDEX idx_user ON test.user (id);

B3 - Balance - Сбалансированное дерево
Деревья 
Хэш индексы - Хэш функция  
Создается на Primary Key
```

**ПРОСТЫЕ ИНДЕКСЫ -** На один столбец

**СОСТАВНЫЕ ИНДЕКСЫ -** На несколько столбцов  
  

==**ОПИСАНИЕ ИНДЕКСА —**==

Без индекса механизму БД пришлось бы сканировать всю таблицу, чтобы найти строки, соответствующие запросу, что может занимать довольно много времени, особенно для больших таблиц.

-Индексы работают путем создания отдельной структуры данных, которая содержит копии индексируемых столбцов в отсортированном порядке. При выполнении запроса механизм БД ищет в индексе строки, соответствующие условиям запроса, а затем извлекает фактические данные из таблицы.

  

==**ПРОБЛЕМЫ —**==

-Индексы могут значительно ускорить выполнение запросов к большим таблицам

Но они могут и негативно повлиять на производительность.  
  
При создании индекса движку базы данных приходится поддерживать структуру данных индекса, а также саму таблицу, что может замедлить операции вставки, обновления и удаления.  
  
Поэтому важно использовать индексы с умом и оптимизировать их при необходимости, чтобы они повышали производительность запросов, а не мешали ей.  

==**Дорого делать много индексов, придется много менять - Занимают много места на Диске**==  
  

==**BTree (Balance дерево) -**== помогает нам искать по точным значениям  
Обеспечивают быстрый поиск по отсортированным значениям столбцов  

![[Untitled 17.png|Untitled 17.png]]

- **Древовидная структура**
- **Листовые и промежуточные вершины**
- **Физически Листья - это страницы**  
    **(Каждая страница - 8кб)**  
    
- **Скорость поиска растет, остальное Падает (Операции вставки, изменения, удаления)**
- **ЛОГОРИФМИЧЕСКАЯ сложность от числа элементов - O(logn) - Бинарный поиск**
- **Лучший поиск по точному значению или диапазону**

```SQL
CREATE INDEX idx_event_date ON events (event_date);

SELECT * FROM events
WHERE event_date BETWEEN '2024/05/01' AND '2011/06/01'
```

  

==**HASH**== - **Поиск по точному совпадению Основывается на Хеш Таблицах, где данные распределяются по Хешам**

![[Untitled 1 10.png|Untitled 1 10.png]]

- **Прогоняем строку, через математическую функцию и получаем на выходе число - HASH**
- **Если HASH одинаковый - складывает в один бакет**
- **Сложность O(1)**
- **Нельзя искать по диапазону**
- **Хеш индекс хранится на Диске**
- **Хеш мапа хранится в Оперативке**

```SQL
CREATE INDEX idx_hash_email ON users USING HASH (email);

SELECT * FROM users WHERE email = 'jony@mail.ru';
```

  

==**GIST-**== **индексы предназначены для индексации сложных типов данных, таких как геометрические данные. Они могут использоваться для различных типов запросов, включая поиск ближайших соседей и запросы, использующие геометрические функции.**

  

==**GIN - Generalized Inverted Index**  
  
==**Индексация неатомарных структур данных**  
**- Массивы**  
**- JSON**  
**- Полнотекстовый поиск**  

Для каждого элемента сопоставляется список мест, где этот элемент встречается  
- Вставка замедляется сильнее  
(При добавлении новых страниц придется настраивать индекс)  

```SQL
CREATE INDEX idx_gin_tags ON books USING GIN (tags);

SELECT * FROM books WHERE tags @> '{science, fiction)';
```

  

  

==**НОРМАЛИЗАЦИЯ и ДЕНОРМАЛИЗАЦИЯ**==

==**Первая Нормальная Форма**==  
**- Нет дублирующихся строк**  
**- Все атрибуты Атомарны**  
**- Нет повторяющихся Атрибутов с одинаковым смыслом**  

==**Вторая Нормальная Форма**  
  
==**- Отношение находится в первой НФ**  
**- Есть первичный Ключ**  
**- Все неключевые атрибуты функционально зависят от Ключа целиком, но не от его части**  

**Состовной ключ может быть использован**

==**Третья Нормальная Форма**  
  
==**- Отношение находится во второй НФ**  
**- Неключевые атрибуты напрямую зависят только от Первичного ключа, но не от других Атрибутов**  

  

==**Транзакция**== ==—== это применение одного или более изменения к БД. Например, при создании/обновлении/удалении записи мы выполняем транзакцию.  
  
Важно контролировать выполнение таких операций в целях обеспечения согласованности данных и обработки возможных ошибок.  

На практике, запросы, как правило, не отправляются в БД по одному, они группируются и выполняются как часть транзакции.

**Транзакции имеют 4 стандартных свойства** (`ACID`):

- **==АТОМАРНОСТЬ==** (`atomicity`) — все операции транзакции должны быть успешно завершены. В противном случае, транзакция прерывается, а все изменения отменяются (происходит откат к предыдущему состоянию)
- ==**СОГЛАСОВАННОСТЬ**== (`consistency`) — состояние должно изменться в полном соответствии с операциями транзакции
- ==**ИЗОЛЯЦИЯ**== или автономность (`isolation`) — транзакции не зависят друг от друга и не оказывают друг на друга никакого влияния
- ==**НАДЕЖНОСТЬ**== (`durability`) — результат звершенной транзакции должен сохраняться при поломке системы

  

==**ТРАНЗАКЦИИ - 4 уровня**====  
1 -  
====**Грязное чтение -**==  
**Самый быстрый, самая плохая Согласованность (Отладка - Нестрогие отчеты)**  
**- Read uncommitted (MySQL)**  
**- Read committed (PostgreSQL)**  
  
  
==**2 - Защита от Грязного чтения**==

**- Видит зафиксированные измения из других Транзакций**  
**—Read committed**  
**Феномен неповторяющегося Чтения**  
**Феномен Фантомом**  

  
==**3 - Repeatable read (Повторяемое чтение)**==  
**Защита от Неповторяющегося Чтения - Мы не видим в исполняющейся транзакции измененные и удаленные записи другой транзакцией.**  
**Но все еще видим вставленные записи из другой транзакции. Чтение фантомов никуда не уходит.**  
**В Постгрес убрали Чтение фантомов**  
  

==**4 - Serializable - Самый медленный, лучшая согласованность**==  
**Мы получаем максимальную согласованность данных, никакие лишние данные не зафиксируются. Цена за это медленная скорость транзакций из-за частых lock'ов поэтому при плохой архитектуре приложения это может сыграть с Вами злую шутку.**  

  

### Пример транзакции SQL

```SQL
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 123;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 456;

COMMIT TRANSACTION;

ROLLBACK - Откатиться или Вернуться
```

  

В этой транзакции выполняются два оператора для перевода 100 единиц валюты со счета 123 на счет 456.  
Оператор BEGIN TRANSACTION начинает транзакцию, а оператор COMMIT TRANSACTION завершает её.  

**Если во время транзакции произойдет ошибка, например сбой питания или нарушение ограничений, то база данных автоматически откатит транзакцию и отменит все внесенные изменения.**

Транзакции важны для управления БД, поскольку они обеспечивают целостность и непротиворечивость данных. Без транзакций было бы трудно обеспечить правильное и последовательное выполнение операций, особенно в средах, где к базе данных могут одновременно обращаться несколько пользователей.

  

  

|                                                   |                                                                            |
| ------------------------------------------------- | -------------------------------------------------------------------------- |
| `**CREATE**`                                      | ==`Создает новую таблицу, представление таблицы или другой объект в БД`==  |
| `ALTER`                                           | Модифицирует существующий в БД объект, такой как таблица                   |
| `DROP`                                            | Удаляет существующую таблицу, представление таблицы или другой объект в БД |
| `**SELECT**` **-** ВЫБРАТЬ ДАННЫЕ                 | Извлекает записи из одной или нескольких таблиц                            |
| `INSERT`                                          | Создает записи                                                             |
| `UPDATE`                                          | Модифицирует записи                                                        |
| `DELETE`                                          | Удаляет записи                                                             |
| `GRANT`                                           | Наделяет пользователя правами                                              |
| `REVOKE`                                          | Отменяет права пользователя                                                |
| `FROM` - отсюда                                   |                                                                            |
| `JOIN` - присоедини                               |                                                                            |
| `WHERE` - с таким условием                        |                                                                            |
| `GROUP` `BY` - сгруппируй данные                  |                                                                            |
| `ORDER` `BY` - отсортируй данные                  |                                                                            |
| `LIMIT` - нужное кол-во результатов               |                                                                            |
| `HAVING` - для фильтрации результатов группировки |                                                                            |

==**GROUP BY -**==

это оператор SQL, используемый для группировки строк с одинаковыми значениями в одном или нескольких столбцах в итоговые строки, например, “найти общий объем продаж для каждого продукта”.

Оператор GROUP BY используется вместе с оператором SELECT и требует, чтобы в операторе SELECT использовалась хотя бы одна агрегатная функция, например SUM, COUNT, AVG, MAX или MIN. За оператором GROUP BY обычно следует имя (имена) столбца (столбцов), по которым необходимо сгруппировать данные.

Например, если у вас есть таблица “Sales” (“Продажи”) со столбцами “Product” (“Продукт”), “Date” (“Дата”) и “Sales Amount” (“Сумма продаж”), и вы хотите найти общую сумму продаж для каждого продукта, вы можете использовать следующий SQL-запрос:

```SQL
SELECT Product, SUM([Sales Amount])as TotalSales
FROM Sales
GROUP BY Product;
```

  

**В чем разница между операторами DELETE и TRUNCATE ? - используются для удаления данных из таблицы**

Оператор DELETE используется для удаления определенных строк из таблицы на основе условия, указанного в предложении WHERE. Он также может использоваться для удаления всех строк из таблицы без указания условия. Оператор DELETE удаляет строки по одной, что может быть медленным процессом для больших таблиц.

Оператор TRUNCATE используется для удаления всех строк из таблицы за один раз. Это более быстрый метод удаления данных по сравнению с DELETE. Однако, TRUNCATE не позволяет использовать предложение WHERE и не может выборочно удалять определенные строки.

Еще одно различие между DELETE и TRUNCATE заключается в том, что DELETE можно откатить с помощью журнала транзакций, а TRUNCATE – нет. После выполнения оператора TRUNCATE данные удаляются из таблицы навсегда.

В общем, если вы хотите выборочно удалить определенные строки из таблицы или откатить изменения, используйте оператор DELETE. Если нужно удалить все строки из таблицы и освободить дисковое пространство, используемое таблицей, следует использовать оператор TRUNCATE.

  

==**Что такое временная таблица и как она используется?**==

Временная таблица – это тип таблицы, которая создается и существует только на время сеанса или транзакции. Она не хранится в базе данных постоянно и удаляется автоматически.

Временные таблицы можно создать с помощью оператора CREATE TEMPORARY TABLE. Они могут быть созданы в памяти или на диске, в зависимости от системы базы данных и конфигурации.

Одним из распространенных вариантов использования временных таблиц является хранение и обработка промежуточных результатов в сложных запросах, особенно в тех, которые включают соединения или агрегирование. Например, временная таблица может использоваться для хранения результатов операции соединения, которые затем могут быть использованы для дальнейших манипуляций или соединения с другими таблицами на последующих этапах запроса.

  

==**В чем разница между предложениями HAVING и WHERE? - Используются для фильтрации данных в запросе**==

Предложение **WHERE** используется для фильтрации отдельных строк перед группировкой или агрегированием  
Предложение **HAVING** – для фильтрации групп строк после группировки или агрегирования.

  

Предложение **WHERE** используется для фильтрации данных перед их группировкой или агрегированием и применяется в операторах **SELECT, UPDATE и DELETE.** Оно фильтрует данные на основе условий, которые применяются к отдельным строкам.

Например, если вы хотите получить данные обо всех сотрудниках, чья зарплата превышает 50 000 долларов, вы можете использовать предложение **WHERE** в операторе **SELECT:**

```SQL
SELECT *
FROM employees
WHERE salary > 50000;
```

Предложение **HAVING** используется для фильтрации данных после их группировки или агрегирования и применяется только с оператором **SELECT**. Оно фильтрует данные на основе условий, которые применяются к группам строк.

Допустим, вы хотите получить среднюю зарплату сотрудников в каждом отделе и показать только те отделы, где средняя зарплата превышает 50 000 долларов. Вы можете использовать предложение **HAVING** в операторе **SELECT:**

```SQL
SELECT department, AVG(salary)
FROM employees
GROUPBY department
HAVING AVG(salary) > 50000;
```

  

  

==**Что такое нормализация и почему она важна?**==

Нормализация – это процесс организации данных в базе таким образом, чтобы уменьшить их избыточность и обеспечить целостность. Она включает в себя разбиение базы данных на более мелкие, более управляемые таблицы и установление связей между ними.

Нормализация важна по нескольким причинам. Во-первых, она помогает устранить избыточность данных, которая может привести к несоответствиям и ошибкам. Организуя данные в отдельных таблицах и связывая их между собой, мы можем гарантировать, что каждый фрагмент информации хранится только один раз, что упрощает обновление и обслуживание.

Во-вторых, нормализация помогает поддерживать согласованность и точность данных. Когда данные распределены по нескольким таблицам, мы можем установить правила и ограничения, которые обеспечат правильный ввод данных и их соответствие определенным стандартам.

Наконец, нормализация облегчает процессы запроса и анализа данных. Разбив базу данных на более мелкие и конкретные таблицы, мы можем эффективнее извлекать данные и манипулировать ими.

  

==**ГОРИЗОНТАЛЬНОЕ МАСШТАБИРОВАНИЕ**==

Оптимизация запросов  
  
Нормализация БД - Если сильно Нормализовано -  
Денормализация БД - Если с джойнами ок -  
  
Можем завести Индексы новые - Если ок -  
  
Портиционирование -  
  
Шардирование - части на разных шардах  
  
Репликация - Мастер для записи - Много инстансов для чтения  

  

==**Шардирование —**== это **принцип проектирования базы данных, при котором части одной таблицы размещаются на разных шардах**. Шард — узел кластера, который может состоять из одной или нескольких реплик. Реплики — это серверы, на которых дублируются данные в рамках шарда. Запрос на чтение или запись в шард может быть отправлен на любую его реплику, выделенного мастера нет.

  

==**Репликация -**== полное копирование БД на такой же сервер.

Основной сервер назовем "Мастер", а дополнительные - "Реплика". Любой из этих серверов будем называть "Нода" (node).

Писать мы сможем только в мастер. А реплики будут вытягивать из мастера все изменения (синхронизироваться).

![[Untitled 2 8.png|Untitled 2 8.png]]

  

![[Untitled 3 5.png|Untitled 3 5.png]]

## ==**Масштабируемся дальше**==

Спортзал и днем и ночью забит модными бруталами. Генеральный директор решает открывать филиалы по всей Москве.

После 30-го филиала стали учащаться жалобы от администраторов на тормоза нашей системы.

Оказывается:• теперь БД не может переварить так много записей• да и место на диске стремительно заканчивается

Что будем делать? Конечно, шардироваться!

## ==**Горизонтальное шардирование**==

В отличии от репликации, шардирование не дублирует данные, а разделяет их по нодам.

Давай разложим все наши записи на 4 ноды.

Ключом шардирования будет barber_id. Так мы будем уверены, что все записи к одному мастеру будут физически находиться на одной ноде.

Остаток от деления barber_id на 4 (количество шардов) = номеру шарда, в который мы положим запись.

  

![[Untitled 4 4.png|Untitled 4 4.png]]

  

![[Untitled 5 3.png|Untitled 5 3.png]]

  

==Шардирование vs Репликация==

- отказоустойчивость -> репликация
- много чтения -> репликация или шардирование
- много записи -> шардирование

==Горизонтальное vs Вертикальное шардирование==

- в основном запросы по ключу -> горизонтальное шардирование
- таблицы тесно связаны -> горизонтальное шардирование
- батчёвые запросы -> вертикальное шардирование
- поиск по разным наборам столбцов -> вертикальное шардирование

  

  

  

  

  

==**АГРЕГИРУЮЩИЕ ФУНКЦИИ**==  
MIN  
MAX  
COUNT  
SUM  
  

  

==**ТИПЫ ОБЪЕДИНЕНИЙ**==

- `INNER JOIN` — возвращает записи, имеющиеся в обеих таблицах
- `LEFT JOIN` — возвращает записи из левой таблицы, даже если такие записи отсутствуют в правой таблице
- `RIGHT JOIN` — возвращает записи из правой таблицы, даже если такие записи отсутствуют в левой таблице
- `FULL JOIN` — возвращает все записи объединяемых таблиц
- `CROSS JOIN` — возвращает все возможные комбинации строк обеих таблиц
- `SELF JOIN` — используется для объединения таблицы с самой собой  
      
      
    

==**ЛОГИЧЕСКИЕ ОПЕРАТОРЫ**==

|   |   |
|---|---|
|`ALL`|Сравнивает все значения|
|`AND`|Объединяет условия (все условия должны совпадать)|
|`ANY`|Сравнивает одно значение с другим, если последнее совпадает с условием|
|`BETWEEN`|Проверяет вхождение значения в диапазон от минимального до максимального|
|`EXISTS`|Определяет наличие строки, соответствующей определенному критерию|
|`IN`|Выполняет поиск значения в списке значений|
|`LIKE`|Сравнивает значение с похожими с помощью операторов подстановки|
|`NOT`|Инвертирует (меняет на противоположное) смысл других логических операторов, например, NOT EXISTS, NOT IN и т.д.|
|`OR`|Комбинирует условия (одно из условий должно совпадать)|
|`IS NULL`|Определяет, является ли значение нулевым|
|`UNIQUE`|Определяет уникальность строки|

Предложение `ORDER BY` используется для сортировки данных по возрастанию (`ASC`) или убыванию (`DESC`). Многие СУБД по умолчанию выполняют сортировку по возрастанию.

  

Предложение `GROUP BY` используется совместно с инструкцией `SELECT` для группировки записей. Оно указывается после `WHERE` и перед `ORDER BY`.

  

Ключевое слово `DISTINCT` используется совместно с инструкцией `SELECT` для возврата только уникальных записей (без дубликатов).

  

  

  

Предложение/оператор `UNION` используется для комбинации результатов двух и более инструкций `SELECT`. При этом, возвращаются только уникальные записи.

  

Предложение `UNION ALL` также используется для объединения результатов двух и более инструкций `SELECT`. При этом, возвращаются все записи, включая дубликаты.

  

- `INTERSECT` — используется для комбинации результатов двух и более `SELECT`, но возвращаются только строки из первого `SELECT`, совпадающие со строками из второго `SELECT`
- `EXCEPT|MINUS` — возвращаются только строки из первого `SELECT`, отсутствующие во втором `SELECT`

  

  

Предложение `HAVING` используется для фильтрации результатов группировки. `WHERE` используется для применения условий к колонкам, а `HAVING` — к группам, созданным с помощью `GROUP BY`.

`HAVING` должно указываться после `GROUP BY`, но перед `ORDER BY` (при наличии).

  
  
Добиваемся сериализации - снапшоты это параллельное исполнение - идет по снапшоту и в конце Постгрес проверяет  

  

Как чистить Индексы - Команда Вакум - Фул Вакум

  

Для Хранения объектов близким к бизнесу

  

можно построить схему

  

Схема Он райт