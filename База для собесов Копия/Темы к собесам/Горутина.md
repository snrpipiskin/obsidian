---
noteId: 1743196626619
---

# Горутина

Горутина — это **[[obsidian/База для собесов Копия/Темы к собесам/Go Runtime#Основные компоненты планировщика|легковесный поток (thread)]]** в языке Go, который управляется **[[obsidian/База для собесов Копия/Темы к собесам/Планировщик|планировщиком Go]]**. Она позволяет выполнять код **параллельно**, но при этом занимает **меньше ресурсов**, чем обычный поток ОС.

## Преимущества горутин над тредами

![[browser_qtFNUZ8CbP.png]]

**Ключевые плюсы:**
- **Более высокая производительность**: меньшее потребление памяти (стек от 2 КБ) и быстрое переключение контекста.
- **Простая модель конкурентности**: основана на каналах (CSP), что минимизирует проблемы с блокировками (mutex hell).
- **Масштабируемость**: можно запускать десятки тысяч горутин на одном ядре.

---

## Как работает горутина?

1.  **Управляется runtime Go**: Работает через [[obsidian/База для собесов Копия/Темы к собесам/Go Runtime|шедулер]] (планировщик Go), а не напрямую через планировщик ОС.
    -   Шедулер использует модель **M:N**: множество горутин (G) мультиплексируются на меньшее количество системных потоков (M).
2.  **Динамический стек**:
    -   Начинается с ~2 КБ ([[obsidian/База для собесов Копия/Темы к собесам/Память в Go#Стек (Stack) - ограничен размером 1МБ|стек]]).
    -   Растёт и уменьшается автоматически при необходимости.
    -   Лимиты (Go 1.19+): 1 ГБ для 64-бит, 250 МБ для 32-бит.
3.  **Запуск**: Через ключевое слово `go`.

```go
go myFunction()
```

### Размер стека

Структура стека (упрощенно):

```go
type stack struct {
	lo uintptr
	hi uintptr
}
```

В отличие от системного потока (обычно 1-2 МБ фиксированно), горутина экономна, что позволяет создавать их в огромном количестве.

### GOMAXPROCS

Параметр **[[Планировщик#** GOMAXPROCS и работа с потоками**|GOMAXPROCS]]** определяет количество логических процессоров (P), которые могут одновременно выполнять код Go. По умолчанию равен числу ядер CPU.

---

## Конкурентность в Go

В Go многопоточность реализуется через два основных примитива:

-   **Горутины** — единицы исполнения.
-   **[[30 Interests/31 Programming/Go/База для собесов/Темы к собесам/Каналы|Каналы (channels)]]** — потокобезопасные "трубы" для обмена данными и синхронизации горутин.

---

## Сравнение: Процессы vs Потоки vs Горутины

![[browser_gkWMKdw1YU.png]]

### Процессы
Процесс — это экземпляр выполняющейся программы.
-   **Изоляция**: Имеет собственное адресное пространство памяти. Сбой процесса не влияет на остальные.
-   **Ресурсы**: Тяжеловесный объект (файловые дескрипторы, переменные среды).

### Потоки (Threads)
Поток — легковесная единица выполнения *внутри* процесса.
-   **Общая память**: Все потоки процесса делят одно адресное пространство.
-   **Переключение**: Требует syscall (дорого).

### Горутины (Goroutines)
-   **Память**: Общая (в рамках процесса Go), но стек свой.
-   **Переключение**: Дешевое (в userspace, без syscall).

> **В Linux** процессы и потоки технически реализуются через схожие структуры (`task_struct`), но отличаются уровнем изоляции (флагами `clone()`).

---

## Пример использования (HTTP-запросы)

Обработка каждого входящего запроса в отдельной горутине — классический паттерн сервера.

```go
func handleRequest(req *http.Request) {
    // Обработка запроса
}

func main() {
    requests := fetchRequests()
    for _, req := range requests {
        go handleRequest(req) // Запуск горутины
    }
}
```

---

## Проблемы и DataRace

> **DataRace** (гонка данных) — ситуация, когда несколько горутин одновременно обращаются к одной области памяти, и минимум одна операция — запись.

Возможные проблемы:
-   Непредсказуемое поведение программы.
-   **Утечки горутин**: Если горутина заблокирована навечно (например, чтение из nil-канала) и не может завершиться.

---

## Дополнительные источники

-   [Конкуренция (Concurrency) и Параллелизм (Parallelism) в Go / habr](https://habr.com/ru/sandbox/152886/)