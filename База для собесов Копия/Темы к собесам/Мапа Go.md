---
noteId: 1743196631837
---

# Мапа в Go

**Map** — это встроенная хэш-таблица для хранения пар "ключ-значение". Это неупорядоченная структура данных, которая в Go является **ссылочным типом** (указатель на структуру управления в памяти).

## 1. Базовая информация

- **Инициализация**: Требует `make` или литерал. Запись в `nil`-мапу вызывает панику.
- **Типы ключей**: Только **comparable** (поддерживают оператор == ).
    - **Подходят**: Числа, строки, указатели, каналы, структуры (если все их поля сравнимы).
    - **Не подходят**: Слайсы, мапы, функции.
- **Безопасность**: Чтение безопасно. Одновременная запись и чтение или две записи из разных горутин вызовут фатальную ошибку (`concurrent map writes`). Для синхронизации используются `sync.Mutex` или `sync.Map`.

---

## 2. Общие принципы хэш-таблиц

Хэш-таблица превращает ключ в индекс массива для быстрого доступа ($O(1)$ в среднем).

### Основные свойства
- **Равномерность**: Данные распределены по бакетам максимально случайно.
- **Детерминированность**: Один и тот же ключ всегда дает один и тот же хэш.
- **Эффективность**: Операции поиска, вставки и удаления выполняются максимально быстро.

### Обработка коллизий
Коллизия — когда разные ключи получают один и тот же индекс.
1.  **Метод цепочек (Chaining)**: Каждая ячейка (бакет) хранит список элементов с одинаковым индексом.
2.  **Метод открытой адресации**: Ищется следующая свободная ячейка по определенному алгоритму (линейный, квадратичный пробинг).

---

## 3. Классическая реализация (< 1.24)

До версии 1.24 в Go использовалась реализация на основе бакетов и метода цепочек.

### Структура hmap (Заголовок)
В памяти мапа представлена структурой `hmap`, которая хранит метаданные:

```go
type hmap struct {
    count     int            // Количество элементов
    flags     uint8          // Флаги (например, идет ли запись)
    B         uint8          // log2 от количества бакетов (2^B)
    noverflow uint16         // Приблизительное число overflow-бакетов
    hash0     uint32         // Рандомизатор (seed) хэша
    buckets   unsafe.Pointer // Указатель на массив бакетов
    oldbuckets unsafe.Pointer // Указатель на бакеты во время эвакуации
    nevacuate uintptr        // Прогресс эвакуации
    extra     *mapextra      // Доп. поля (overflow бакеты без указателей)
}
```

### Бакеты (bmap)
Каждый бакет (`bmap`) хранит до 8 пар ключ-значение.

```go
type bmap struct {
    tophash [8]uint8 // Верхние 8 бит хэша для быстрого поиска
    // Далее в памяти лежат 8 ключей, затем 8 значений
    // В конце — указатель на overflow-бакет
}
```

- **Tophash**: При поиске Go сначала сравнивает `tophash`. Если он не совпадает, ключ даже не проверяется целиком, что экономит время.
- **Overflow**: Если в бакет нужно положить 9-й элемент, создается новый бакет, на который указывает первый.

---

## 4. Новая реализация: Swiss Tables (1.24+)

С версии **Go 1.24** мапа перешла на архитектуру **Swiss Tables**, использующую SIMD и открытую адресацию.

### Система типов (ABI)
Компилятор генерирует `abi.MapType` для каждого типа мапы, где описаны:
- `Hasher`: Как считать хэш для этого ключа.
- `Equal`: Как сравнивать ключи.
- `GCData`: Где лежат указатели для сборщика мусора.

### Структура данных
Теперь данные организованы в **Группы (Groups)** по 8 слотов.

```go
type Group struct {
    ctrls [8]byte      // Метаданные (Empty, Deleted, или H2 хэш)
    slots [8]Slot      // Сами данные (ключи и значения)
}
```

### Алгоритм работы (Swiss Tables)
1.  **Хэширование (H1/H2)**:
    - **H1 (старшие биты)**: Определяют индекс стартовой группы.
    - **H2 (7 бит)**: Попадают в `ctrls` при вставке.
2.  **SIMD-поиск**: Go загружает все 8 байт `ctrls` в регистр CPU и одной инструкцией ищет совпадение с искомым `H2`.
3.  **Открытая адресация**: Если в группе нет места или ключа, мапа ищет в следующей группе (Quadratic Probing).
4.  **Tombstones**: Удаленные элементы помечаются особым байтом, чтобы поиск "проходил" сквозь них, но вставка могла занять их место.

---

## 5. Рост и Эвакуация (Universal)

Механизм расширения мапы универсален:

- **Load Factor**: Отношение количества элементов к количеству бакетов/групп.
    - В классической мапе критический порог — **6.5**.
    - В Swiss Tables порог выше (~0.875), так как они плотнее.
- **Инкрементальная эвакуация**: При расширении мапа не переносит все данные сразу (это бы вызвало "фриз"). Она создает новые бакеты в 2 раза больше, и переносит данные по частям при каждой операции `mapassign` (записи) или `mapdelete` (удаления).

---

## 6. Конкурентный доступ

| Характеристика | Обычная map + Mutex | sync.Map |
| --- | --- | --- |
| **Сложность** | Нужно управлять блокировками вручную. | Встроенная синхронизация. |
| **Производительность** | Быстрая везде, кроме очень высокой конкуренции на запись. | Медленнее на записях, очень быстрая на чтениях. |
| **Когда применять** | По умолчанию почти всегда. | Для кешей (ReadOnly) или когда горутины пишут в разные ключи. |

---

## 7. Глубокие оптимизации

- **String Optimization**: Ключи-строки хэшируются через `runtime_faststr`. Если строка длинная, сначала сравниваются длина и края строки, чтобы не считать тяжелый хэш зря.
- **Indirect Key/Value**: Если размер ключа или значения превышает 128 байт, Go автоматически заменяет их в мапе на **указатели**, чтобы структура бакета/группы не стала слишком громоздкой.

---

## 8. Инициализация: make vs var

```go
// Способ 1: Объявление (nil мапа)
var m map[string]int 
// m == nil. Читать можно m["key"] -> 0. Писать нельзя -> паника.

// Способ 2: Инициализация с аллокацией
m = make(map[string]int, 100) 
```

> [!important]
> Указание **capacity** в `make` критически важно для производительности. Если вы знаете, что в мапе будет 1000 элементов, укажите это. Это избавит runtime от множества циклов переаллокации и эвакуации данных.

---

## 9. Дополнительные источники

- [[obsidian/База для собесов Копия/Темы к собесам/Мапа Go#Внутреннее устройство map в Go > 1.25 (Swiss Tables) и Система Типов|Deep Dive: Swiss Tables & ABI]]
- [Мапы в Go: уровень Pro / habr](https://habr.com/ru/companies/avito/articles/774618/)
- [Разбираемся с sync.Map / habr](https://habr.com/ru/articles/338718)
