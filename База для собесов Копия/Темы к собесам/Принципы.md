---
noteId: 1743196638732
---

## **SOLID**

Принципы SOLID помогают разрабатывать поддерживаемый и читаемый код. Они используются для создания архитектурно правильных и масштабируемых программ.

### **S) Single Responsibility Principle (Принцип единственной ответственности)**

Каждый модуль выполняет **только одну задачу**.

- **Разбиваем задачу на модули**
    
- **Каждая сущность отвечает за одно действие**
    
- **Избегаем антипаттерна "God Object"**
    

> Если класс выполняет слишком много задач, код становится сложным и трудно тестируемым.

### **O) Open-Closed Principle (Принцип открытости-закрытости)**

Программы должны быть **открыты для расширения, но закрыты для модификации**.

- **Нельзя изменять уже протестированный код**
    
- **Добавляем новую функциональность через наследование или композицию**
    
- **В Go можно встраивать структуры и создавать свои типы**
    

> Если приходится менять код, чтобы добавить новую возможность, значит принцип нарушен.

### **L) Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**

> **Наследуемый класс должен дополнять, а не изменять поведение родительского.**

- Дочерние классы должны сохранять ожидаемое поведение
    
- Интерфейс **должен дополнять**, а не **замещать** объект
    

> Если при подстановке дочернего класса в код программа начинает работать некорректно, то принцип нарушен.

### **I) Interface Segregation Principle (Принцип разделения интерфейсов)**

> **Объекты не должны зависеть от интерфейсов, которые они не используют.**

- Разделяем крупные интерфейсы на **узконаправленные**
    
- **Каждый интерфейс должен выполнять только одну задачу**
    
- Код становится **менее связанным**
    

**Пример неправильного интерфейса:**

```
interface Animal {
  eat()
  walk()
  fly()
  swim()
}
```

> Не все животные могут летать или плавать, значит интерфейс должен быть разделен.

### **D) Dependency Inversion Principle (Принцип инверсии зависимостей)**

> **Полагаться нужно на абстракции, а не на конкретные реализации.**

- Код должен зависеть от **абстракций (интерфейсов), а не реализаций**
    
- **Компоненты должны быть слабо связаны**
    
- **Позволяет легче модифицировать и тестировать код**
    

> Иногда добавление этого уровня абстракции требует усилий, но в конечном итоге это окупается.

---

## **YAGNI (You Aren’t Gonna Need It)**

> **Не добавляйте функционал, который не нужен прямо сейчас.**

- Пишите **только необходимый код**
    
- Не загромождайте проект "на будущее"
    
- Если метод или функция больше не используются, удаляйте их
    

> Если в будущем потребуется удаленный код, его всегда можно восстановить из системы контроля версий.

---

## **DRY (Don’t Repeat Yourself)**

> **Не дублируйте код.**

- Дублирование кода увеличивает сложность поддержки
    
- Повторная логика должна быть вынесена в отдельные функции/модули
    
- Перед написанием новой функции проверьте, не реализована ли она уже
    

> Дублирование ведет к необходимости исправлять ошибки в нескольких местах.

---

## **KISS (Keep It Simple, Stupid)**

> **Чем проще код, тем лучше.**

- Избегайте чрезмерной сложности
    
- Самое простое решение зачастую оказывается самым эффективным
    
- Код должен быть понятен даже без детальной документации
    

> Хороший код — это код, который легко читается и поддерживается.